// Generated by CoffeeScript 1.3.1

/*
This file is part of SpokeDM.

SpokeDM is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SpokeDM is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public along with SpokeDM.  
If not, see <http://www.gnu.org/licenses/>.
*/


(function() {
  var SpokeMain, module;

  module = angular.module('spokes', ['ngResource', 'SpokeData', 'SpokeLogic', 'SpokeDataLogic', 'SpokeUtilities', '$strap.directives']);

  module.config(function($routeProvider, $locationProvider) {
    $locationProvider.html5Mode(true);
    return $routeProvider.when(spokesBaseViewUrl + '/:modelkey/:key');
  });

  SpokeMain = (function() {

    SpokeMain.name = 'SpokeMain';

    function SpokeMain($scope, $route, $routeParams, $location, $timeout, $resource, $filter, SPDataSpoke, SPLinkSpoke, SPSearchLogic, SPAlertsLogic, SPSpokeLogic, SPRelinkLogic, SPTypeLogic, SpokeURLUtility) {
      $scope.geterrors = [];
      $scope.geterrorsplash = false;
      $scope.afterNewCallbacks = [];
      $scope.registerNewCallback = function(scope, cb) {
        return $scope.afterNewCallbacks.push({
          "scope": angular.extend({}, scope),
          "fire": cb
        });
      };
      $scope.fireNewCallback = function() {
        var callback;
        callback = $scope.afterNewCallbacks.pop();
        if (!callback) {
          return;
        }
        angular.extend($scope, callback.scope);
        return callback.fire(json.key);
      };
      $scope.$on("spokeLoadError", function(evt, errors) {
        $scope.geterrors = errors;
        return $scope.geterrorsplash = true;
      });
      $scope.$on("$routeChangeSuccess", function() {
        $scope.geterrors = [];
        $scope.geterrorsplash = false;
        $scope.clearAlerts();
        if ($routeParams.key === 'new' && ($scope.spoke.modelkey != null) && ($scope.spoke.key != null)) {
          $scope.spoke.newmodelkey = $routeParams.modelkey;
          if (($scope.spoke.modelkey != null) && ($scope.spoke.key != null) && ($routeParams.modelkey != null) && ($routeParams.key != null)) {
            return $scope.spoke.get(function(json) {
              if (!(json.errors != null) || json.errors.length === 0) {
                $scope.spoke.modelkey = $routeParams.modelkey;
                return $scope.spoke.key = $routeParams.key;
              }
            });
          }
        } else {
          $scope.spoke = new SPDataSpoke();
          $scope.spoke.modelkey = $routeParams.modelkey;
          $scope.spoke.key = $routeParams.key;
          if (($scope.spoke.modelkey != null) && ($scope.spoke.key != null) && ($routeParams.modelkey != null) && ($routeParams.key != null)) {
            return $scope.spoke.get();
          }
        }
      });
      $scope.extDynamicLink = SpokeURLUtility.extDynamicURL;
      SPSearchLogic($scope, $timeout, $resource, $filter, function(axle, row) {
        if (axle.externalurl) {
          return window.location = $scope.extDynamicLink(axle.externalurl, row);
        } else {
          return $scope.spokeDetailFocus(axle, row, 'center');
        }
      });
      SPAlertsLogic($scope, $timeout);
      SPSpokeLogic($scope, $location, SPDataSpoke);
      SPRelinkLogic($scope, SPLinkSpoke);
      SPTypeLogic($scope, SPDataSpoke);
      $route.reload();
    }

    return SpokeMain;

  })();

  this.SpokeMain = SpokeMain;

}).call(this);
